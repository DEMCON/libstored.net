// SPDX-FileCopyrightText: 2025 Guus Kuiper
//
// SPDX-License-Identifier: MIT

using System.Buffers.Binary;
using Microsoft.Extensions.Logging;

namespace LibStored.Net.Protocol;

/// <summary>
/// A protocol layer that adds a 16-bit CRC (polynomial 0xBAAD) for message integrity.
/// Calculates and verifies CRC values for encoded and decoded messages.
/// </summary>
public class Crc16Layer : ProtocolLayer
{
    private static readonly ushort[] crc16Table =
    [
        0x0000, 0xBAAD, 0xCFF7, 0x755A, 0x2543, 0x9FEE, 0xEAB4, 0x5019, 0x4A86, 0xF02B, 0x8571,
        0x3FDC, 0x6FC5, 0xD568, 0xA032, 0x1A9F, 0x950C, 0x2FA1, 0x5AFB, 0xE056, 0xB04F, 0x0AE2,
        0x7FB8, 0xC515, 0xDF8A, 0x6527, 0x107D, 0xAAD0, 0xFAC9, 0x4064, 0x353E, 0x8F93, 0x90B5,
        0x2A18, 0x5F42, 0xE5EF, 0xB5F6, 0x0F5B, 0x7A01, 0xC0AC, 0xDA33, 0x609E, 0x15C4, 0xAF69,
        0xFF70, 0x45DD, 0x3087, 0x8A2A, 0x05B9, 0xBF14, 0xCA4E, 0x70E3, 0x20FA, 0x9A57, 0xEF0D,
        0x55A0, 0x4F3F, 0xF592, 0x80C8, 0x3A65, 0x6A7C, 0xD0D1, 0xA58B, 0x1F26, 0x9BC7, 0x216A,
        0x5430, 0xEE9D, 0xBE84, 0x0429, 0x7173, 0xCBDE, 0xD141, 0x6BEC, 0x1EB6, 0xA41B, 0xF402,
        0x4EAF, 0x3BF5, 0x8158, 0x0ECB, 0xB466, 0xC13C, 0x7B91, 0x2B88, 0x9125, 0xE47F, 0x5ED2,
        0x444D, 0xFEE0, 0x8BBA, 0x3117, 0x610E, 0xDBA3, 0xAEF9, 0x1454, 0x0B72, 0xB1DF, 0xC485,
        0x7E28, 0x2E31, 0x949C, 0xE1C6, 0x5B6B, 0x41F4, 0xFB59, 0x8E03, 0x34AE, 0x64B7, 0xDE1A,
        0xAB40, 0x11ED, 0x9E7E, 0x24D3, 0x5189, 0xEB24, 0xBB3D, 0x0190, 0x74CA, 0xCE67, 0xD4F8,
        0x6E55, 0x1B0F, 0xA1A2, 0xF1BB, 0x4B16, 0x3E4C, 0x84E1, 0x8D23, 0x378E, 0x42D4, 0xF879,
        0xA860, 0x12CD, 0x6797, 0xDD3A, 0xC7A5, 0x7D08, 0x0852, 0xB2FF, 0xE2E6, 0x584B, 0x2D11,
        0x97BC, 0x182F, 0xA282, 0xD7D8, 0x6D75, 0x3D6C, 0x87C1, 0xF29B, 0x4836, 0x52A9, 0xE804,
        0x9D5E, 0x27F3, 0x77EA, 0xCD47, 0xB81D, 0x02B0, 0x1D96, 0xA73B, 0xD261, 0x68CC, 0x38D5,
        0x8278, 0xF722, 0x4D8F, 0x5710, 0xEDBD, 0x98E7, 0x224A, 0x7253, 0xC8FE, 0xBDA4, 0x0709,
        0x889A, 0x3237, 0x476D, 0xFDC0, 0xADD9, 0x1774, 0x622E, 0xD883, 0xC21C, 0x78B1, 0x0DEB,
        0xB746, 0xE75F, 0x5DF2, 0x28A8, 0x9205, 0x16E4, 0xAC49, 0xD913, 0x63BE, 0x33A7, 0x890A,
        0xFC50, 0x46FD, 0x5C62, 0xE6CF, 0x9395, 0x2938, 0x7921, 0xC38C, 0xB6D6, 0x0C7B, 0x83E8,
        0x3945, 0x4C1F, 0xF6B2, 0xA6AB, 0x1C06, 0x695C, 0xD3F1, 0xC96E, 0x73C3, 0x0699, 0xBC34,
        0xEC2D, 0x5680, 0x23DA, 0x9977, 0x8651, 0x3CFC, 0x49A6, 0xF30B, 0xA312, 0x19BF, 0x6CE5,
        0xD648, 0xCCD7, 0x767A, 0x0320, 0xB98D, 0xE994, 0x5339, 0x2663, 0x9CCE, 0x135D, 0xA9F0,
        0xDCAA, 0x6607, 0x361E, 0x8CB3, 0xF9E9, 0x4344, 0x59DB, 0xE376, 0x962C, 0x2C81, 0x7C98,
        0xC635, 0xB36F, 0x09C2,
    ];

    private readonly ILogger<Crc16Layer>? _logger;
    private readonly ushort _init = 0xffff;
    private ushort _crc;

    /// <summary>
    /// Initializes a new instance of the <see cref="Crc16Layer"/> class.
    /// </summary>
    /// <param name="logger">Optional logger for CRC warnings.</param>
    public Crc16Layer(ILogger<Crc16Layer>? logger = null)
    {
        _logger = logger;
        _crc = _init; // Initialize CRC to the initial value
    }

    /// <summary>
    /// Decodes a buffer, verifying the CRC and passing valid data to the next layer.
    /// </summary>
    /// <param name="buffer">The buffer to decode, including CRC bytes.</param>
    public override void Decode(Span<byte> buffer)
    {
        if (buffer.Length < 2)
        {
            return;
        }

        ushort crc = _init;
        for (int i = 0; i < buffer.Length - 2; i++)
        {
            crc = Compute(buffer[i], crc);
        }

        if (crc != (ushort)(buffer[buffer.Length - 2] << 8 | buffer[buffer.Length - 1]))
        {
            // CRC mismatch, ignore the packet
            _logger?.LogWarning("Invalid crc check: {Actual}, expected: {Expected}", buffer[^1], crc);
            return;
        }

        base.Decode(buffer.Slice(0, buffer.Length - 2));
    }

    /// <summary>
    /// Encodes a buffer, updating the CRC and appending it when the message is complete.
    /// </summary>
    /// <param name="buffer">The data to encode.</param>
    /// <param name="last">Indicates if this is the last buffer in the message.</param>
    public override void Encode(ReadOnlySpan<byte> buffer, bool last)
    {
        foreach (byte b in buffer)
        {
            _crc = Compute(b, _crc);
        }

        base.Encode(buffer, false);

        if (last)
        {
            byte[] crcBytesBig = new byte[2];
            BinaryPrimitives.WriteUInt16BigEndian(crcBytesBig, _crc);
            base.Encode(crcBytesBig, true);
            _crc = _init; // Reset CRC for the next message
        }
    }

    /// <inheritdoc />
    public override int Mtu() => base.Mtu() switch
    {
        0 or > 256 => 256,
        <= 3 => 2,
        var x => x - 2,
    };

    private ushort Compute(byte input, ushort crc) => (ushort)(Crc16Layer.crc16Table[input ^ (byte)(crc >> 8)] ^ (ushort)(crc << 8));
}
