# LibStored.Net

A 100% native C# implementation of the [libstored](https://github.com/DEMCON/libstored) library, which is a library for storing and retrieving data in a structured way, using a store definition file. The library provides a set of layers to build applications that can communicate with a Debugger or Synchroniser.

Based on [libstored](https://demcon.github.io/libstored) by Jochem Rutgers, [GitHub](https://github.com/DEMCON/libstored).

## Scope

The goal of this library is to provide native C# implementation of a part the libstored library, such that it can be used in C# applications without the need for a C++/CLI wrapper. The library provides a set of layers to build applications that can communicate with a Debugger or Synchroniser.

This C# implementation target C# GUI's that synchronize data with and embedded device. The embedded device can be a microcontroller, FPGA, or any other device that can communicate using the libstored protocol. The C# implementation is not intended to be a full replacement of the C++ implementation, but rather a subset of the features that are needed for C# GUI applications.

On the embedded side, the libstored Debugger is a great way to debug a live running embedded application from a remote system. In C# and the tooling and editor for it, there are other option for debugging, so there is no need to a full featured libstored Debugger.

```mermaid
flowchart TD
    CsApp[Application - C# GUI]
    CsStore[Store]
    CsSync[Synchroniser]
    CsProt[Protocol Layers]

    SyncTrans[Sync Transport Layer - ZeroMQ]
    DbgTrans[Debug Transport Layer - ZeroMQ]

    EdApp[Embedded Device - C++/C]
    EdStore[Store]
    EdDbg[Debugger]
    EdDbgProt[Protocol Layers]
    EdSync[Synchroniser]
    EdSyncProt[Protocol Layers]

    CsApp --> CsStore
    CsStore --> CsSync
    CsSync --> CsProt
    CsProt --> SyncTrans

    EdApp --> EdStore
    EdStore --> EdDbg
    EdDbg --> EdDbgProt
    EdDbgProt --> DbgTrans
    EdStore --> EdSync
    EdSync --> EdSyncProt
    EdSyncProt --> SyncTrans
```

## Features

### Application layers
- Debugger
  - Supported commands (rwelvi): read, write, echo, list, identification & version.
  - List and find do not work when multiple stores are mapped to a single debugger.
- Synchronizer

### Protocol layers
- AsciiEscapeLayer
- TerminalLayer
- Crc8Layer (0xA6)
- Crc16Layer (0xBAAD)
- LoggingLayer using ILogger
- LoopbackLayer
- BufferLayer
- SegmentationLayer
- ArqLayer

### Transport layers
- ZeroMQ using [NetMQ](https://netmq.readthedocs.io/)
  - DebugZeroMQLayer: to connect to the Debugger
  - SyncZeroMQLayer: to connect to the Synchronizer (connection)

### Store generation
C# stores can be generated from the `<name>Meta.py`. Use the [libstored](https://demcon.github.io/libstored) generator to parse the `<name>.st` and output the `<name>Meta.py`.
The `generator.py` script in this repository under `/python`

Make sure a virtual environment is created, activated and the requirement.txt is installed in it.
```bash
cd python
python -m venv .venv
./.venv/Scripts/activate
pip install -r requirements.txt
```

Call the generator script to creat a C# store that implements the `Store` abstract class, which can then be mapped to the `Synchronizer` and `Debugger` in LibStored.Net.

```bash
python generator.py -m <name>Meta.py -o output_dir
```

#### Source Generator

The C# code can be automatically be generated from a metadata`*Store.json` file generated by the `generator.py` script (or in the future - see [libstored issue#76](https://github.com/DEMCON/libstored/issues/76)). Reference the store(s) metadata as AddinionalFiles:
```xml
<ItemGroup>
    <AdditionalFiles Include="TestStore.json" />
</ItemGroup>
```
For more information about the Source Generator see the [README.md](src/LibStored.Net.Generator/README.md).

### Thread safety
In [libstored](https://demcon.github.io/libstored) you are only allowed to access a store from a single thread. The store may only be accessed from a single thread (the thread that runs the NetMQPoller)
This C# implementation adds locking to all read and writes to the store buffer.
The C# store is therefore safe to use from any thread, at the cost of some performance.
Another option would be to create a store per thread, and synchronize them using the `Synchronizer` and communicating within the same process.

### Missing / unsupported / future features?
- Only little endian stores are supported.
- Functions and streams are not supported.
- Heatshrink compression is not supported.

#### Missing layers
- PolledLayer(s)
- FileLayer
- NamedPipeLayer
- StdioLayer (use `libstored.Stdio2Zmq` as alternative for local debugging, not production ready)
- SerialLayer (use `libstored.Serial2Zmq` as alternative for local debugging, not production ready)

#### Store source generation
Currently, C# stores are created manually by running a Python script using the Meta.py output of [libstored](demcon.github.io/libstored).
A C# Source Generator could automate this process of converting the store data structure to a C# class, using the hash, names, types, offset and
sizes of all objects in the store.

A C# Source Generator could generate the stores automatically during compile-time of the C# application using this library. The input of the source generated is the `.rtf` / `.csv` / `Meta.py`, or parse the actual store definition in `.st` files. Maybe [libstored](demcon.github.io/libstored) can be extended to generate a language agnostic `.json` file with the store definition, which can be used by the C# Source Generator to generate the store class. The `.json` file would be the easiest to implement since its easy to parse and can contain all relevant store data. The Source Generator that transform a `*.Store.json` has been implemented, as described in the [README.md](src/LibStored.Net.Generator/README.md).

Another option is to create a template file for the C# version of the store in [libstored](demcon.github.io/libstored).

#### Unsupported features

Types: `Pointer`, `Pointer32` and `Pointer64` are not supported, as they are not needed in C# applications. The `ptr32` and `ptr64` types are used to store pointers to other objects in the store, which is not needed in C# applications as the objects are stored in managed memory. These types will be mapped to unsigned integers (`uint` and `ulong`) in the C# implementation.

## Example

```csharp
using LibStored.Net;
using LibStored.Net.Protocol;
using LibStored.Net.ZeroMQ;
using NetMQ;
using NetMQ.Sockets;

// Make sure this ExampleStore is created by the source generator or python script.
ExampleStore store = new();

// Attach the store to the debugger
Debugger debugger = new();
debugger.Map(store);

// Expose the Debugger using ZeroMQ
using ResponseSocket socket = new("@tcp://localhost:5555");
DebugZeroMQLayer debugLayer = new(socket);
debugLayer.Wrap(debugger);

// Run the message loop to receive requests from the Debugger
using (NetMQPoller poller = [socket])
{
    socket.ReceiveReady += (_, _) =>
    {
        debugLayer.ReceiveAll();
    };

    // Start the event loop
    poller.Run();
}
```

Connect to the debugger using the [libstored.gui](https://github.com/DEMCON/libstored/tree/master/python) on the port that is exposed.

```bash
python -m libstored.gui -p 5555
```

## Compatibility

Tested with:
- [v1.7.1](https://github.com/DEMCON/libstored/releases/tag/v1.7.1) (see note  below)
- [v1.8.0](https://github.com/DEMCON/libstored/releases/tag/v1.8.0)

See [libstored changelog](https://demcon.github.io/libstored/doc/changelog.html) for the changes. There do not seem to be breaking changes from <v1.7.1 to v1.7.1 for this C# implementation.

### libstored >v1.7.1
The ZeroMQ socket type changed from `PAIR` to `DEALER` for the SyncZeroMQLayer. Make sure the exact same socket type is used at both ends of the protocol, so `PAIR` - `PAIR` or `DEALER` - `DEALER`, but not `PAIR` - `DEALER`. When connecting to libstored v1.7.1 or lower, use the `PAIR` socket type. For version v1.8 or higher of libstored, use `DEALER`.

## Build

Install the [.NET SDK](https://dotnet.microsoft.com/download), version 9.0 or higher, and run the following command in the root directory of the project:

Build the library and examples:
```bash
dotnet build
```

Run the example:
You also need to have a [container runtime](https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/setup-tooling?tabs=windows&pivots=vscode#container-runtime) installed: Podman or Docker.
```bash
dotnet run --project examples\Sync\LibStored.Net.Example.AppHost\LibStored.Net.Example.AppHost.csproj
```

Run the tests:
```bash
dotnet test
```
